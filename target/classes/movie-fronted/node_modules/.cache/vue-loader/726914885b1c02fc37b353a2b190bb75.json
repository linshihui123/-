{"remainingRequest":"D:\\ideaProject\\demo\\src\\main\\resources\\movie-fronted\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\ideaProject\\demo\\src\\main\\resources\\movie-fronted\\src\\components\\KnowledgeGraph.vue?vue&type=script&lang=js","dependencies":[{"path":"D:\\ideaProject\\demo\\src\\main\\resources\\movie-fronted\\src\\components\\KnowledgeGraph.vue","mtime":1769506644565},{"path":"D:\\ideaProject\\demo\\src\\main\\resources\\movie-fronted\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1768463919512},{"path":"D:\\ideaProject\\demo\\src\\main\\resources\\movie-fronted\\node_modules\\vue-loader\\lib\\index.js","mtime":1768463917873}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBheGlvcyBmcm9tICdheGlvcycKY29uc3QgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMnKQoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdLbm93bGVkZ2VHcmFwaCcsCiAgcHJvcHM6IHsKICAgIG1vdmllQ291bnQ6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAxMAogICAgfSwKICAgIGN1cnJlbnRVc2VyOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgZGVmYXVsdDogbnVsbAogICAgfQogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGdyYXBoSW5zdGFuY2U6IG51bGwsCiAgICAgIGdyYXBoRGF0YTogewogICAgICAgIG5vZGVzOiBbXSwKICAgICAgICBlZGdlczogW10KICAgICAgfSwKICAgICAgc2VsZWN0ZWROb2RlVHlwZTogJ2FsbCcsCiAgICAgIHNlYXJjaEtleXdvcmQ6ICcnLAogICAgICBzaG93RGV0YWlsRGlhbG9nOiBmYWxzZSwKICAgICAgbm9kZURldGFpbDogbnVsbCwKICAgICAgbG9jYWxNb3ZpZUNvdW50OiAxMCwKICAgICAgY29yZU1vdmllTWFwOiBuZXcgTWFwKCksIC8vIOWtmOWCqOeUteW9seiKgueCuUlEIC0+IOWtkOiKgueCuUlE5pWw57uECiAgICAgIG5vZGVQb3NpdGlvbnM6IG5ldyBNYXAoKSwgLy8g5a2Y5YKo6IqC54K55L2N572u5YWz57O777yM55So5LqO6Lef6ZqP5ouW5YqoCiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLAogICAgICBkcmFnZ2VkTm9kZTogbnVsbCwKICAgICAgZHJhZ1N0YXJ0UG9zOiB7IHg6IDAsIHk6IDAgfQogICAgfQogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgLy8g56Gu5L+d55S75biDRE9N5a6M5YWo5Yqg6L295ZCO5Yid5aeL5YyWCiAgICAgIGlmICh0aGlzLiRyZWZzLmdyYXBoQ2FudmFzKSB7CiAgICAgICAgdGhpcy5pbml0R3JhcGgoKQogICAgICAgIHRoaXMubG9jYWxNb3ZpZUNvdW50ID0gdGhpcy5tb3ZpZUNvdW50IHx8IDEwCiAgICAgICAgdGhpcy5mZXRjaEdyYXBoRGF0YSgpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy4kbWVzc2FnZS5lcnJvcign5Zu+6LCx55S75biDRE9N5YWD57Sg5pyq5om+5Yiw77yBJykKICAgICAgfQogICAgfSkKICB9LAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICAvLyDlvbvlupXplIDmr4Hlrp7kvovlkozkuovku7bvvIzpgb/lhY3lhoXlrZjms4TmvI8KICAgIGlmICh0aGlzLmdyYXBoSW5zdGFuY2UpIHsKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9mZignZHJhZ3N0YXJ0JykKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9mZignZHJhZycpCiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZS5vZmYoJ2RyYWdlbmQnKQogICAgICB0aGlzLmdyYXBoSW5zdGFuY2UuZGlzcG9zZSgpCiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZSA9IG51bGwKICAgIH0KICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSkKICB9LAogIG1ldGhvZHM6IHsKICAgIC8vIOWkhOeQhueql+WPo+Wkp+Wwj+WPmOWMlgogICAgaGFuZGxlUmVzaXplKCkgewogICAgICBpZiAodGhpcy5ncmFwaEluc3RhbmNlKSB7CiAgICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLnJlc2l6ZSgpCiAgICAgIH0KICAgIH0sCgogICAgaW5pdEdyYXBoKCkgewogICAgICBpZiAoIWVjaGFydHMpIHsKICAgICAgICB0aGlzLiRtZXNzYWdlLmVycm9yKCdFQ2hhcnRz5bqT5Yqg6L295aSx6LSl77yBJykKICAgICAgICByZXR1cm4KICAgICAgfQogICAgICAvLyDliJ3lp4vljJZFQ2hhcnRz5a6e5L6LCiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZSA9IGVjaGFydHMuaW5pdCh0aGlzLiRyZWZzLmdyYXBoQ2FudmFzKQoKICAgICAgLy8g55uR5ZCs56qX5Y+j5aSn5bCP5Y+Y5YyWCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSkKCiAgICAgIC8vIOe7keWumueCueWHu+S6i+S7tgogICAgICB0aGlzLmdyYXBoSW5zdGFuY2Uub24oJ2NsaWNrJywgKHBhcmFtcykgPT4gewogICAgICAgIGlmIChwYXJhbXMuZGF0YVR5cGUgPT09ICdub2RlJykgewogICAgICAgICAgdGhpcy5zaG93Tm9kZURldGFpbChwYXJhbXMuZGF0YSkKICAgICAgICB9CiAgICAgIH0pCiAgICB9LAoKICAgIGZldGNoR3JhcGhEYXRhKCkgewogICAgICBjb25zdCBhcGlVcmwgPSBgaHR0cDovL2xvY2FsaG9zdDo4MDgxL2FwaS9rZy9ncmFwaC1kYXRhP21vdmllQ291bnQ9JHt0aGlzLmxvY2FsTW92aWVDb3VudH1gCiAgICAgIGF4aW9zLmdldChhcGlVcmwpCiAgICAgICAgICAudGhlbihyZXMgPT4gewogICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7CiAgICAgICAgICAgICAgdGhpcy5ncmFwaERhdGEgPSByZXMuZGF0YS5kYXRhIHx8IHJlcy5kYXRhCiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaCgpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgICAuY2F0Y2goZXJyID0+IHsKICAgICAgICAgICAgdGhpcy4kbWVzc2FnZS5lcnJvcign5pWw5o2u6K+35rGC5aSx6LSl77yaJyArIGVyci5tZXNzYWdlKQogICAgICAgICAgICBjb25zb2xlLmVycm9yKCflm77osLHmlbDmja7or7fmsYLlpLHotKXvvJonLCBlcnIpCiAgICAgICAgICB9KQogICAgfSwKCiAgICAvLyDkvJjljJblkI7nmoToioLngrnlpKflsI/orqHnrpcKICAgIGdldE5vZGVTaXplKG5hbWUsIGlzQ29yZSkgewogICAgICBjb25zdCBmb250U2l6ZSA9IGlzQ29yZSA/IDE0IDogMTIKICAgICAgY29uc3QgYmFzZVNpemUgPSBpc0NvcmUgPyA2MCA6IDQwCiAgICAgIGNvbnN0IGxlbmd0aCA9IG5hbWUgPyBuYW1lLmxlbmd0aCA6IDAKCiAgICAgIC8vIOagueaNruaWh+acrOmVv+W6puiwg+aVtOWkp+WwjwogICAgICBpZiAobGVuZ3RoIDw9IDQpIHJldHVybiBiYXNlU2l6ZQogICAgICBpZiAobGVuZ3RoIDw9IDgpIHJldHVybiBiYXNlU2l6ZSAqIDEuMgogICAgICByZXR1cm4gYmFzZVNpemUgKiAxLjUKICAgIH0sCgogICAgLy8g55Sf5oiQ5Zu+6LCx5pWw5o2u77yI5qC45b+D5pS56L+b77ya5bu656uL6IqC54K56Lef6ZqP5YWz57O777yJCiAgICBnZW5lcmF0ZUdyYXBoRGF0YSgpIHsKICAgICAgbGV0IGFsbE5vZGVzID0gWy4uLnRoaXMuZ3JhcGhEYXRhLm5vZGVzXQogICAgICBsZXQgYWxsRWRnZXMgPSBbLi4udGhpcy5ncmFwaERhdGEuZWRnZXNdCgogICAgICAvLyDmuIXnqbrkuYvliY3nmoTmmKDlsIQKICAgICAgdGhpcy5jb3JlTW92aWVNYXAuY2xlYXIoKQogICAgICB0aGlzLm5vZGVQb3NpdGlvbnMuY2xlYXIoKQoKICAgICAgLy8g562b6YCJ6YC76L6RCiAgICAgIGxldCBmaWx0ZXJlZE5vZGVzID0gW10KICAgICAgbGV0IGZpbHRlcmVkRWRnZXMgPSBbXQoKICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb2RlVHlwZSA9PT0gJ2FsbCcpIHsKICAgICAgICBmaWx0ZXJlZE5vZGVzID0gYWxsTm9kZXMKICAgICAgICBmaWx0ZXJlZEVkZ2VzID0gYWxsRWRnZXMKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCB0YXJnZXROb2RlcyA9IGFsbE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUudHlwZSA9PT0gdGhpcy5zZWxlY3RlZE5vZGVUeXBlKQogICAgICAgIGlmICh0YXJnZXROb2Rlcy5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHJldHVybiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdLCBjYXRlZ29yaWVzOiB0aGlzLmdldE5vZGVDYXRlZ29yaWVzKCkgfQogICAgICAgIH0KICAgICAgICBjb25zdCB0YXJnZXROb2RlSWRzID0gdGFyZ2V0Tm9kZXMubWFwKG5vZGUgPT4gbm9kZS5pZCkKICAgICAgICBjb25zdCByZWxhdGVkRWRnZXMgPSBhbGxFZGdlcy5maWx0ZXIoZWRnZSA9PgogICAgICAgICAgICB0YXJnZXROb2RlSWRzLmluY2x1ZGVzKGVkZ2Uuc291cmNlKSB8fCB0YXJnZXROb2RlSWRzLmluY2x1ZGVzKGVkZ2UudGFyZ2V0KQogICAgICAgICkKICAgICAgICBjb25zdCByZWxhdGVkTm9kZUlkcyA9IG5ldyBTZXQoKQogICAgICAgIHJlbGF0ZWRFZGdlcy5mb3JFYWNoKGVkZ2UgPT4gewogICAgICAgICAgcmVsYXRlZE5vZGVJZHMuYWRkKGVkZ2Uuc291cmNlKQogICAgICAgICAgcmVsYXRlZE5vZGVJZHMuYWRkKGVkZ2UudGFyZ2V0KQogICAgICAgIH0pCiAgICAgICAgZmlsdGVyZWROb2RlcyA9IGFsbE5vZGVzLmZpbHRlcihub2RlID0+IHJlbGF0ZWROb2RlSWRzLmhhcyhub2RlLmlkKSkKICAgICAgICBmaWx0ZXJlZEVkZ2VzID0gcmVsYXRlZEVkZ2VzCiAgICAgIH0KCiAgICAgIC8vIOWFs+mUruivjeaQnOe0ogogICAgICBpZiAodGhpcy5zZWFyY2hLZXl3b3JkKSB7CiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRoaXMuc2VhcmNoS2V5d29yZC50cmltKCkudG9Mb3dlckNhc2UoKQogICAgICAgIGZpbHRlcmVkTm9kZXMgPSBmaWx0ZXJlZE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubmFtZSAmJiBub2RlLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkKSkKICAgICAgICBjb25zdCBmaWx0ZXJlZE5vZGVJZHMgPSBmaWx0ZXJlZE5vZGVzLm1hcChub2RlID0+IG5vZGUuaWQpCiAgICAgICAgZmlsdGVyZWRFZGdlcyA9IGZpbHRlcmVkRWRnZXMuZmlsdGVyKGVkZ2UgPT4KICAgICAgICAgICAgZmlsdGVyZWROb2RlSWRzLmluY2x1ZGVzKGVkZ2Uuc291cmNlKSAmJiBmaWx0ZXJlZE5vZGVJZHMuaW5jbHVkZXMoZWRnZS50YXJnZXQpCiAgICAgICAgKQogICAgICB9CgogICAgICBjb25zdCBub2RlQ2F0ZWdvcmllcyA9IHRoaXMuZ2V0Tm9kZUNhdGVnb3JpZXMoKQoKICAgICAgLy8g5pS26ZuG5omA5pyJ55S15b2x6IqC54K5CiAgICAgIGNvbnN0IG1vdmllTm9kZXMgPSBmaWx0ZXJlZE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUudHlwZSA9PT0gJ21vdmllJykKCiAgICAgIC8vIOesrOS4gOatpe+8muW7uueri+eUteW9seiKgueCueS4juWtkOiKgueCueeahOaYoOWwhOWFs+ezuwogICAgICBtb3ZpZU5vZGVzLmZvckVhY2gobW92aWVOb2RlID0+IHsKICAgICAgICBpZiAoIW1vdmllTm9kZS5pZCkgcmV0dXJuCgogICAgICAgIC8vIOaJvuWIsOS4juW9k+WJjeeUteW9seiKgueCueebuOWFs+eahOi+uQogICAgICAgIGNvbnN0IG1vdmllRWRnZXMgPSBmaWx0ZXJlZEVkZ2VzLmZpbHRlcihlZGdlID0+CiAgICAgICAgICAgIGVkZ2Uuc291cmNlID09PSBtb3ZpZU5vZGUuaWQgfHwgZWRnZS50YXJnZXQgPT09IG1vdmllTm9kZS5pZAogICAgICAgICkKCiAgICAgICAgLy8g5pS26ZuG5omA5pyJ5a2Q6IqC54K5SUQKICAgICAgICBjb25zdCBjaGlsZE5vZGVJZHMgPSBbXQogICAgICAgIG1vdmllRWRnZXMuZm9yRWFjaChlZGdlID0+IHsKICAgICAgICAgIGNvbnN0IGNoaWxkSWQgPSBlZGdlLnNvdXJjZSA9PT0gbW92aWVOb2RlLmlkID8gZWRnZS50YXJnZXQgOiBlZGdlLnNvdXJjZQogICAgICAgICAgLy8g5o6S6Zmk55S15b2x6IqC54K56Ieq6LqrCiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBmaWx0ZXJlZE5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBjaGlsZElkICYmIG4udHlwZSAhPT0gJ21vdmllJykKICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHsKICAgICAgICAgICAgY2hpbGROb2RlSWRzLnB1c2goY2hpbGRJZCkKICAgICAgICAgIH0KICAgICAgICB9KQoKICAgICAgICAvLyDlrZjlgqjmmKDlsITlhbPns7sKICAgICAgICB0aGlzLmNvcmVNb3ZpZU1hcC5zZXQobW92aWVOb2RlLmlkLCBjaGlsZE5vZGVJZHMpCgogICAgICAgIC8vIOS4uuavj+S4quWtkOiKgueCueWtmOWCqOWFtueItueUteW9seiKgueCueeahOS9jee9ruWFs+ezuwogICAgICAgIGNoaWxkTm9kZUlkcy5mb3JFYWNoKGNoaWxkSWQgPT4gewogICAgICAgICAgaWYgKCF0aGlzLm5vZGVQb3NpdGlvbnMuaGFzKGNoaWxkSWQpKSB7CiAgICAgICAgICAgIHRoaXMubm9kZVBvc2l0aW9ucy5zZXQoY2hpbGRJZCwgbmV3IFNldCgpKQogICAgICAgICAgfQogICAgICAgICAgdGhpcy5ub2RlUG9zaXRpb25zLmdldChjaGlsZElkKS5hZGQobW92aWVOb2RlLmlkKQogICAgICAgIH0pCiAgICAgIH0pCgogICAgICAvLyDnrKzkuozmraXvvJrorqHnrpfluIPlsYAKICAgICAgY29uc3Qgbm9kZXMgPSBbXQogICAgICBjb25zdCBlZGdlcyA9IFtdCgogICAgICAvLyDorqHnrpfnlLvluIPkuK3lv4PngrkKICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB0aGlzLiRyZWZzLmdyYXBoQ2FudmFzLm9mZnNldFdpZHRoCiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHRoaXMuJHJlZnMuZ3JhcGhDYW52YXMub2Zmc2V0SGVpZ2h0CiAgICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXNXaWR0aCAvIDIKICAgICAgY29uc3QgY2VudGVyWSA9IGNhbnZhc0hlaWdodCAvIDIKCiAgICAgIC8vIOS9v+eUqOaUvuWwhOeKtuW4g+WxgAogICAgICBjb25zdCByYWRpdXNQZXJNb3ZpZSA9IE1hdGgubWluKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpICogMC4zNSAvIE1hdGgubWF4KDEsIG1vdmllTm9kZXMubGVuZ3RoKQoKICAgICAgLy8g5aSE55CG55S15b2x6IqC54K5CiAgICAgIG1vdmllTm9kZXMuZm9yRWFjaCgobW92aWVOb2RlLCBpbmRleCkgPT4gewogICAgICAgIGlmICghbW92aWVOb2RlLmlkKSByZXR1cm4KCiAgICAgICAgLy8g6K6h566X55S15b2x6IqC54K55L2N572u77yI5pS+5bCE54q25biD5bGA77yJCiAgICAgICAgY29uc3QgYW5nbGUgPSAoaW5kZXggLyBtb3ZpZU5vZGVzLmxlbmd0aCkgKiAyICogTWF0aC5QSQogICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcmFkaXVzUGVyTW92aWUgKiAoaW5kZXggKyAxKQogICAgICAgIGNvbnN0IG1vdmllWCA9IGNlbnRlclggKyBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKQogICAgICAgIGNvbnN0IG1vdmllWSA9IGNlbnRlclkgKyBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKQoKICAgICAgICAvLyDmt7vliqDnlLXlvbHoioLngrkKICAgICAgICBub2Rlcy5wdXNoKHsKICAgICAgICAgIGlkOiBtb3ZpZU5vZGUuaWQsCiAgICAgICAgICBuYW1lOiBtb3ZpZU5vZGUubmFtZSwKICAgICAgICAgIGNhdGVnb3J5OiAwLAogICAgICAgICAgeDogbW92aWVYLAogICAgICAgICAgeTogbW92aWVZLAogICAgICAgICAgc3ltYm9sU2l6ZTogdGhpcy5nZXROb2RlU2l6ZShtb3ZpZU5vZGUubmFtZSwgdHJ1ZSksCiAgICAgICAgICBpdGVtU3R5bGU6IG5vZGVDYXRlZ29yaWVzWzBdLml0ZW1TdHlsZSwKICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgIGZvbnRTaXplOiAxMiwKICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLAogICAgICAgICAgICBjb2xvcjogJyMwMDAnLAogICAgICAgICAgICBvdmVyZmxvdzogJ2JyZWFrJywKICAgICAgICAgICAgbGluZUhlaWdodDogMTYKICAgICAgICAgIH0sCiAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsCiAgICAgICAgICB0eXBlOiAnbW92aWUnCiAgICAgICAgfSkKCiAgICAgICAgLy8g5re75Yqg55S15b2x6IqC54K555qE5a2Q6IqC54K5CiAgICAgICAgY29uc3QgY2hpbGROb2RlSWRzID0gdGhpcy5jb3JlTW92aWVNYXAuZ2V0KG1vdmllTm9kZS5pZCkgfHwgW10KICAgICAgICBjaGlsZE5vZGVJZHMuZm9yRWFjaCgoY2hpbGRJZCwgY2hpbGRJbmRleCkgPT4gewogICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gZmlsdGVyZWROb2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gY2hpbGRJZCkKICAgICAgICAgIGlmICghY2hpbGROb2RlKSByZXR1cm4KCiAgICAgICAgICAvLyDmo4Dmn6XmmK/lkKblt7Lnu4/mt7vliqDov4for6XlrZDoioLngrnvvIjpgb/lhY3ph43lpI3vvIkKICAgICAgICAgIGlmIChub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gY2hpbGRJZCkpIHJldHVybgoKICAgICAgICAgIC8vIOiuoeeul+WtkOiKgueCueS9jee9ru+8iOWbtOe7leeUteW9seiKgueCue+8jOaUvuWwhOeKtuWIhuW4g++8iQogICAgICAgICAgY29uc3QgYW5nbGUgPSAoY2hpbGRJbmRleCAvIGNoaWxkTm9kZUlkcy5sZW5ndGgpICogTWF0aC5QSSAqIDIKICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDgwIC8vIOWbuuWumuWNiuW+hO+8jOehruS/neWtkOiKgueCueWbtOe7leeItuiKgueCueWQiOmAgui3neemuwogICAgICAgICAgY29uc3QgY2hpbGRYID0gbW92aWVYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpCiAgICAgICAgICBjb25zdCBjaGlsZFkgPSBtb3ZpZVkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkKCiAgICAgICAgICAvLyDnoa7lrproioLngrnnsbvlnovntKLlvJUKICAgICAgICAgIGNvbnN0IGNhdElkeCA9IG5vZGVDYXRlZ29yaWVzLmZpbmRJbmRleChjID0+IGMubmFtZSA9PT0gY2hpbGROb2RlLnR5cGUpCgogICAgICAgICAgbm9kZXMucHVzaCh7CiAgICAgICAgICAgIGlkOiBjaGlsZE5vZGUuaWQsCiAgICAgICAgICAgIG5hbWU6IGNoaWxkTm9kZS5uYW1lLAogICAgICAgICAgICBjYXRlZ29yeTogY2F0SWR4ID49IDAgPyBjYXRJZHggOiA0LAogICAgICAgICAgICB4OiBjaGlsZFgsCiAgICAgICAgICAgIHk6IGNoaWxkWSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogdGhpcy5nZXROb2RlU2l6ZShjaGlsZE5vZGUubmFtZSwgZmFsc2UpLAogICAgICAgICAgICBpdGVtU3R5bGU6IG5vZGVDYXRlZ29yaWVzW2NhdElkeCA+PSAwID8gY2F0SWR4IDogNF0uaXRlbVN0eWxlLAogICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgICAgZm9udFNpemU6IDEwLAogICAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsCiAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdicmVhaycsCiAgICAgICAgICAgICAgbGluZUhlaWdodDogMTQKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLAogICAgICAgICAgICB0eXBlOiBjaGlsZE5vZGUudHlwZQogICAgICAgICAgfSkKICAgICAgICB9KQogICAgICB9KQoKICAgICAgLy8g56ys5LiJ5q2l77ya5re75Yqg6L65CiAgICAgIGZpbHRlcmVkRWRnZXMuZm9yRWFjaChlZGdlID0+IHsKICAgICAgICAvLyDnoa7kv53ovrnnmoTkuKTkuKroioLngrnpg73lrZjlnKgKICAgICAgICBpZiAobm9kZXMuZmluZChuID0+IG4uaWQgPT09IGVkZ2Uuc291cmNlKSAmJiBub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gZWRnZS50YXJnZXQpKSB7CiAgICAgICAgICBlZGdlcy5wdXNoKHsKICAgICAgICAgICAgc291cmNlOiBlZGdlLnNvdXJjZSwKICAgICAgICAgICAgdGFyZ2V0OiBlZGdlLnRhcmdldCwKICAgICAgICAgICAgbGFiZWw6IHsKICAgICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICAgIGZvcm1hdHRlcjogZWRnZS5sYWJlbCwKICAgICAgICAgICAgICBmb250U2l6ZTogMTAsCiAgICAgICAgICAgICAgY29sb3I6ICcjNjY2JywKICAgICAgICAgICAgICBwb3NpdGlvbjogJ21pZGRsZScKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgd2lkdGg6IDEuNSwKICAgICAgICAgICAgICBjb2xvcjogJyNCMEM0REUnLAogICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcsCiAgICAgICAgICAgICAgb3BhY2l0eTogMC44CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgfQogICAgICB9KQoKICAgICAgcmV0dXJuIHsKICAgICAgICBub2Rlczogbm9kZXMsCiAgICAgICAgZWRnZXM6IGVkZ2VzLAogICAgICAgIGNhdGVnb3JpZXM6IG5vZGVDYXRlZ29yaWVzCiAgICAgIH0KICAgIH0sCgogICAgZ2V0Tm9kZUNhdGVnb3JpZXMoKSB7CiAgICAgIHJldHVybiBbCiAgICAgICAgeyBuYW1lOiAnbW92aWUnLCBpdGVtU3R5bGU6IHsgY29sb3I6ICcjOEEyQkUyJywgYm9yZGVyV2lkdGg6IDIsIGJvcmRlckNvbG9yOiAnIzRCMDA4MicgfSB9LAogICAgICAgIHsgbmFtZTogJ2RpcmVjdG9yJywgaXRlbVN0eWxlOiB7IGNvbG9yOiAnI0ZGNDUwMCcsIGJvcmRlcldpZHRoOiAxLCBib3JkZXJDb2xvcjogJyNGRjYzNDcnIH0gfSwKICAgICAgICB7IG5hbWU6ICdhY3RvcicsIGl0ZW1TdHlsZTogeyBjb2xvcjogJyNGRjYzNDcnLCBib3JkZXJXaWR0aDogMSwgYm9yZGVyQ29sb3I6ICcjRkY0NTAwJyB9IH0sCiAgICAgICAgeyBuYW1lOiAncmVnaW9uJywgaXRlbVN0eWxlOiB7IGNvbG9yOiAnI0ZGRDcwMCcsIGJvcmRlcldpZHRoOiAxLCBib3JkZXJDb2xvcjogJyNGRkE1MDAnIH0gfSwKICAgICAgICB7IG5hbWU6ICdnZW5yZScsIGl0ZW1TdHlsZTogeyBjb2xvcjogJyMzMkNEMzInLCBib3JkZXJXaWR0aDogMSwgYm9yZGVyQ29sb3I6ICcjMjI4QjIyJyB9IH0KICAgICAgXQogICAgfSwKCiAgICByZW5kZXJHcmFwaCgpIHsKICAgICAgaWYgKCF0aGlzLmdyYXBoSW5zdGFuY2UpIHJldHVybgoKICAgICAgY29uc3QgZ3JhcGhEYXRhID0gdGhpcy5nZW5lcmF0ZUdyYXBoRGF0YSgpCiAgICAgIGNvbnN0IF90aGlzID0gdGhpcwoKICAgICAgLy8g6K6h566X55S75biD5aSn5bCPCiAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gdGhpcy4kcmVmcy5ncmFwaENhbnZhcy5vZmZzZXRXaWR0aAogICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSB0aGlzLiRyZWZzLmdyYXBoQ2FudmFzLm9mZnNldEhlaWdodAoKICAgICAgLy8gRUNoYXJ0c+mFjee9rgogICAgICBjb25zdCBvcHRpb24gPSB7CiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI0ZGRkZGRicsCiAgICAgICAgdG9vbHRpcDogewogICAgICAgICAgdHJpZ2dlcjogJ2l0ZW0nLAogICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjk1KScsCiAgICAgICAgICBib3JkZXJDb2xvcjogJyNFNUU1RTUnLAogICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICBib3JkZXJSYWRpdXM6IDYsCiAgICAgICAgICBwYWRkaW5nOiBbOCwgMTJdLAogICAgICAgICAgdGV4dFN0eWxlOiB7IGNvbG9yOiAnIzMzMycsIGZvbnRTaXplOiAxMiB9LAogICAgICAgICAgZm9ybWF0dGVyOiBwYXJhbXMgPT4gewogICAgICAgICAgICBpZiAocGFyYW1zLmRhdGFUeXBlID09PSAnbm9kZScpIHsKICAgICAgICAgICAgICBjb25zdCB0eXBlcyA9IFsn55S15b2xJywn5a+85ryUJywn5ryU5ZGYJywn5Zyw5Yy6Jywn57G75Z6LJ10KICAgICAgICAgICAgICByZXR1cm4gYCR7cGFyYW1zLm5hbWV9PGJyLz7nsbvlnovvvJoke3R5cGVzW3BhcmFtcy5kYXRhLmNhdGVnb3J5XSB8fCAn5pyq55+lJ31gCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5kYXRhVHlwZSA9PT0gJ2VkZ2UnID8gYOWFs+ezu++8miR7cGFyYW1zLmRhdGEubGFiZWwuZm9ybWF0dGVyfWAgOiBwYXJhbXMubmFtZQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgbGVnZW5kOiB7CiAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgZGF0YTogWwogICAgICAgICAgICB7bmFtZTon55S15b2xJywgaWNvbjogJ2NpcmNsZScsIHRleHRTdHlsZToge2NvbG9yOiAnIzhBMkJFMid9fSwKICAgICAgICAgICAge25hbWU6J+WvvOa8lCcsIGljb246ICdjaXJjbGUnLCB0ZXh0U3R5bGU6IHtjb2xvcjogJyNGRjQ1MDAnfX0sCiAgICAgICAgICAgIHtuYW1lOifmvJTlkZgnLCBpY29uOiAnY2lyY2xlJywgdGV4dFN0eWxlOiB7Y29sb3I6ICcjRkY2MzQ3J319LAogICAgICAgICAgICB7bmFtZTon5Zyw5Yy6JywgaWNvbjogJ2NpcmNsZScsIHRleHRTdHlsZToge2NvbG9yOiAnI0ZGRDcwMCd9fSwKICAgICAgICAgICAge25hbWU6J+exu+WeiycsIGljb246ICdjaXJjbGUnLCB0ZXh0U3R5bGU6IHtjb2xvcjogJyMzMkNEMzInfX0KICAgICAgICAgIF0sCiAgICAgICAgICB0b3A6IDEwLAogICAgICAgICAgbGVmdDogJ2NlbnRlcicsCiAgICAgICAgICBpdGVtR2FwOiAxNSwKICAgICAgICAgIHRleHRTdHlsZTogeyBmb250U2l6ZTogMTIsIGNvbG9yOiAnIzAwMCcgfSwKICAgICAgICAgIGljb246ICdjaXJjbGUnCiAgICAgICAgfSwKICAgICAgICBzZXJpZXM6IFsKICAgICAgICAgIHsKICAgICAgICAgICAgdHlwZTogJ2dyYXBoJywKICAgICAgICAgICAgbGF5b3V0OiAnbm9uZScsCiAgICAgICAgICAgIHJvYW06IHRydWUsCiAgICAgICAgICAgIHpvb206IDEsCiAgICAgICAgICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sCiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSwKICAgICAgICAgICAgc3ltYm9sOiAnY2lyY2xlJywKICAgICAgICAgICAgc3ltYm9sU2l6ZTogNDAsCiAgICAgICAgICAgIGVkZ2VTeW1ib2w6IFsnY2lyY2xlJywgJ2NpcmNsZSddLAogICAgICAgICAgICBlZGdlU3ltYm9sU2l6ZTogWzQsIDRdLAogICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJywKICAgICAgICAgICAgbGFiZWw6IHsKICAgICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJywKICAgICAgICAgICAgICBjb2xvcjogJyMwMDAnLAogICAgICAgICAgICAgIGZvbnRTaXplOiAxMCwKICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJwogICAgICAgICAgICB9LAogICAgICAgICAgICBlZGdlTGFiZWw6IHsKICAgICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICAgIHBvc2l0aW9uOiAnbWlkZGxlJywKICAgICAgICAgICAgICBmb250U2l6ZTogMTAKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGF0YTogZ3JhcGhEYXRhLm5vZGVzLAogICAgICAgICAgICBsaW5rczogZ3JhcGhEYXRhLmVkZ2VzLAogICAgICAgICAgICBjYXRlZ29yaWVzOiBncmFwaERhdGEuY2F0ZWdvcmllcywKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdzb3VyY2UnLAogICAgICAgICAgICAgIHdpZHRoOiAxLjUsCiAgICAgICAgICAgICAgY3VydmVuZXNzOiAwLjEsCiAgICAgICAgICAgICAgb3BhY2l0eTogMC42CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGVtcGhhc2lzOiB7CiAgICAgICAgICAgICAgZm9jdXM6ICdhZGphY2VuY3knLAogICAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgICAgd2lkdGg6IDIsCiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9CgogICAgICAvLyDmuIXnqbrlubborr7nva7mlrDphY3nva4KICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLmNsZWFyKCkKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLnNldE9wdGlvbihvcHRpb24sIHRydWUpCgogICAgICAvLyDnp7vpmaTml6fnmoTkuovku7bnm5HlkKzlmagKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9mZignZHJhZ3N0YXJ0JykKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9mZignZHJhZycpCiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZS5vZmYoJ2RyYWdlbmQnKQoKICAgICAgLy8g5ouW5Yqo5byA5aeL5LqL5Lu2CiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZS5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24ocGFyYW1zKSB7CiAgICAgICAgaWYgKHBhcmFtcy5kYXRhVHlwZSAhPT0gJ25vZGUnKSByZXR1cm4KCiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWUKICAgICAgICBfdGhpcy5kcmFnZ2VkTm9kZSA9IHBhcmFtcy5kYXRhCiAgICAgICAgX3RoaXMuZHJhZ1N0YXJ0UG9zID0gewogICAgICAgICAgeDogcGFyYW1zLmRhdGEueCwKICAgICAgICAgIHk6IHBhcmFtcy5kYXRhLnkKICAgICAgICB9CiAgICAgIH0pCgogICAgICAvLyDmi5bliqjkuovku7YgLSDmoLjlv4PvvJrlrZDoioLngrnot5/pmo/niLboioLngrkKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9uKCdkcmFnJywgZnVuY3Rpb24ocGFyYW1zKSB7CiAgICAgICAgaWYgKCFfdGhpcy5pc0RyYWdnaW5nIHx8IHBhcmFtcy5kYXRhVHlwZSAhPT0gJ25vZGUnKSByZXR1cm4KCiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBwYXJhbXMuZGF0YQogICAgICAgIGNvbnN0IGR4ID0gY3VycmVudE5vZGUueCAtIF90aGlzLmRyYWdTdGFydFBvcy54CiAgICAgICAgY29uc3QgZHkgPSBjdXJyZW50Tm9kZS55IC0gX3RoaXMuZHJhZ1N0YXJ0UG9zLnkKCiAgICAgICAgLy8g5aaC5p6c5piv55S15b2x6IqC54K56KKr5ouW5Yqo77yM56e75Yqo5omA5pyJ5a2Q6IqC54K5CiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09ICdtb3ZpZScgJiYgX3RoaXMuY29yZU1vdmllTWFwLmhhcyhjdXJyZW50Tm9kZS5pZCkpIHsKICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZUlkcyA9IF90aGlzLmNvcmVNb3ZpZU1hcC5nZXQoY3VycmVudE5vZGUuaWQpCiAgICAgICAgICBjb25zdCBncmFwaE9wdGlvbiA9IF90aGlzLmdyYXBoSW5zdGFuY2UuZ2V0T3B0aW9uKCkKICAgICAgICAgIGNvbnN0IGFsbE5vZGVzID0gZ3JhcGhPcHRpb24uc2VyaWVzWzBdLmRhdGEKCiAgICAgICAgICAvLyDmm7TmlrDmiYDmnInlrZDoioLngrnnmoTkvY3nva4KICAgICAgICAgIGNoaWxkTm9kZUlkcy5mb3JFYWNoKGNoaWxkSWQgPT4gewogICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBhbGxOb2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gY2hpbGRJZCkKICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkgewogICAgICAgICAgICAgIGNoaWxkTm9kZS54ICs9IGR4CiAgICAgICAgICAgICAgY2hpbGROb2RlLnkgKz0gZHkKICAgICAgICAgICAgfQogICAgICAgICAgfSkKCiAgICAgICAgICAvLyDmm7TmlrDlm77ooagKICAgICAgICAgIF90aGlzLmdyYXBoSW5zdGFuY2Uuc2V0T3B0aW9uKHsKICAgICAgICAgICAgc2VyaWVzOiBbewogICAgICAgICAgICAgIGRhdGE6IGFsbE5vZGVzCiAgICAgICAgICAgIH1dCiAgICAgICAgICB9LCB0cnVlKSAvLyDkvb/nlKh0cnVl5Y+C5pWw5by65Yi25pu05pawCiAgICAgICAgfQoKICAgICAgICAvLyDlpoLmnpzmmK/lrZDoioLngrnooqvmi5bliqjvvIzmo4Dmn6XlroPmmK/lkKblsZ7kuo7lpJrkuKrniLboioLngrkKICAgICAgICBlbHNlIGlmIChjdXJyZW50Tm9kZS50eXBlICE9PSAnbW92aWUnICYmIF90aGlzLm5vZGVQb3NpdGlvbnMuaGFzKGN1cnJlbnROb2RlLmlkKSkgewogICAgICAgICAgY29uc3QgcGFyZW50TW92aWVJZHMgPSBBcnJheS5mcm9tKF90aGlzLm5vZGVQb3NpdGlvbnMuZ2V0KGN1cnJlbnROb2RlLmlkKSkKICAgICAgICAgIGNvbnN0IGdyYXBoT3B0aW9uID0gX3RoaXMuZ3JhcGhJbnN0YW5jZS5nZXRPcHRpb24oKQogICAgICAgICAgY29uc3QgYWxsTm9kZXMgPSBncmFwaE9wdGlvbi5zZXJpZXNbMF0uZGF0YQoKICAgICAgICAgIC8vIOaJvuWIsOWvueW6lOeahOeItueUteW9seiKgueCuQogICAgICAgICAgcGFyZW50TW92aWVJZHMuZm9yRWFjaChwYXJlbnRJZCA9PiB7CiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbGxOb2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gcGFyZW50SWQgJiYgbi50eXBlID09PSAnbW92aWUnKQogICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkgewogICAgICAgICAgICAgIC8vIOiuoeeul+eItuiKgueCueeahOaWsOS9jee9ru+8iOS/neaMgeebuOWvueS9jee9ruS4jeWPmO+8iQogICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IGN1cnJlbnROb2RlLnggLSBfdGhpcy5kcmFnU3RhcnRQb3MueAogICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlWSA9IGN1cnJlbnROb2RlLnkgLSBfdGhpcy5kcmFnU3RhcnRQb3MueQogICAgICAgICAgICAgIHBhcmVudE5vZGUueCArPSByZWxhdGl2ZVgKICAgICAgICAgICAgICBwYXJlbnROb2RlLnkgKz0gcmVsYXRpdmVZCgogICAgICAgICAgICAgIC8vIOenu+WKqOivpeeItuiKgueCueeahOWFtuS7luWtkOiKgueCuQogICAgICAgICAgICAgIGlmIChfdGhpcy5jb3JlTW92aWVNYXAuaGFzKHBhcmVudElkKSkgewogICAgICAgICAgICAgICAgY29uc3Qgc2libGluZ0lkcyA9IF90aGlzLmNvcmVNb3ZpZU1hcC5nZXQocGFyZW50SWQpCiAgICAgICAgICAgICAgICBzaWJsaW5nSWRzLmZvckVhY2goc2libGluZ0lkID0+IHsKICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmdJZCAhPT0gY3VycmVudE5vZGUuaWQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nTm9kZSA9IGFsbE5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBzaWJsaW5nSWQpCiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmdOb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nTm9kZS54ICs9IHJlbGF0aXZlWAogICAgICAgICAgICAgICAgICAgICAgc2libGluZ05vZGUueSArPSByZWxhdGl2ZVkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KQoKICAgICAgICAgIC8vIOabtOaWsOWbvuihqAogICAgICAgICAgX3RoaXMuZ3JhcGhJbnN0YW5jZS5zZXRPcHRpb24oewogICAgICAgICAgICBzZXJpZXM6IFt7CiAgICAgICAgICAgICAgZGF0YTogYWxsTm9kZXMKICAgICAgICAgICAgfV0KICAgICAgICAgIH0sIHRydWUpIC8vIOS9v+eUqHRydWXlj4LmlbDlvLrliLbmm7TmlrAKICAgICAgICB9CgogICAgICAgIC8vIOabtOaWsOi1t+Wni+S9jee9rgogICAgICAgIF90aGlzLmRyYWdTdGFydFBvcyA9IHsKICAgICAgICAgIHg6IGN1cnJlbnROb2RlLngsCiAgICAgICAgICB5OiBjdXJyZW50Tm9kZS55CiAgICAgICAgfQogICAgICB9KQoKICAgICAgLy8g5ouW5Yqo57uT5p2f5LqL5Lu2CiAgICAgIHRoaXMuZ3JhcGhJbnN0YW5jZS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKCkgewogICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZQogICAgICAgIF90aGlzLmRyYWdnZWROb2RlID0gbnVsbAogICAgICAgIF90aGlzLmRyYWdTdGFydFBvcyA9IHsgeDogMCwgeTogMCB9CiAgICAgIH0pCgogICAgICAvLyDngrnlh7voioLngrnkuovku7YKICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLm9uKCdjbGljaycsIHBhcmFtcyA9PiB7CiAgICAgICAgaWYgKHBhcmFtcy5kYXRhVHlwZSA9PT0gJ25vZGUnKSB7CiAgICAgICAgICBfdGhpcy5zaG93Tm9kZURldGFpbChwYXJhbXMuZGF0YSkKICAgICAgICB9CiAgICAgIH0pCgogICAgICAvLyDnoa7kv53lm77ooajpgILlupTlrrnlmajlpKflsI8KICAgICAgdGhpcy5ncmFwaEluc3RhbmNlLnJlc2l6ZSgpCiAgICB9LAoKICAgIHNob3dOb2RlRGV0YWlsKG5vZGVNb2RlbCkgewogICAgICBpZiAobm9kZU1vZGVsLmNhdGVnb3J5ICE9PSAwKSB7CiAgICAgICAgdGhpcy4kbWVzc2FnZS5pbmZvKGAke25vZGVNb2RlbC5uYW1lfSB8ICR7WyfnlLXlvbEnLCflr7zmvJQnLCfmvJTlkZgnLCflnLDljLonLCfnsbvlnosnXVtub2RlTW9kZWwuY2F0ZWdvcnldIHx8ICfmnKrnn6UnfWApCiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIC8vIOiOt+WPlueUteW9seivpuaDheS/oeaBrwogICAgICBjb25zdCBkaXJlY3RvcnMgPSB0aGlzLmdyYXBoRGF0YS5lZGdlcwogICAgICAgICAgLmZpbHRlcihlZGdlID0+IGVkZ2Uuc291cmNlID09PSBub2RlTW9kZWwuaWQgJiYgZWRnZS5sYWJlbCA9PT0gJ+WvvOa8lCcpCiAgICAgICAgICAubWFwKGVkZ2UgPT4gewogICAgICAgICAgICBjb25zdCB0Tm9kZSA9IHRoaXMuZ3JhcGhEYXRhLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBlZGdlLnRhcmdldCkKICAgICAgICAgICAgcmV0dXJuIHROb2RlID8gdE5vZGUubmFtZSA6IG51bGwKICAgICAgICAgIH0pCiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pCgogICAgICBjb25zdCBhY3RvcnMgPSB0aGlzLmdyYXBoRGF0YS5lZGdlcwogICAgICAgICAgLmZpbHRlcihlZGdlID0+IGVkZ2Uuc291cmNlID09PSBub2RlTW9kZWwuaWQgJiYgZWRnZS5sYWJlbCA9PT0gJ+S4u+a8lCcpCiAgICAgICAgICAubWFwKGVkZ2UgPT4gewogICAgICAgICAgICBjb25zdCB0Tm9kZSA9IHRoaXMuZ3JhcGhEYXRhLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBlZGdlLnRhcmdldCkKICAgICAgICAgICAgcmV0dXJuIHROb2RlID8gdE5vZGUubmFtZSA6IG51bGwKICAgICAgICAgIH0pCiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pCgogICAgICBjb25zdCByZWdpb25FZGdlID0gdGhpcy5ncmFwaERhdGEuZWRnZXMuZmluZChlZGdlID0+IGVkZ2Uuc291cmNlID09PSBub2RlTW9kZWwuaWQgJiYgZWRnZS5sYWJlbCA9PT0gJ+WcsOWMuicpCiAgICAgIGNvbnN0IGdlbnJlRWRnZSA9IHRoaXMuZ3JhcGhEYXRhLmVkZ2VzLmZpbmQoZWRnZSA9PiBlZGdlLnNvdXJjZSA9PT0gbm9kZU1vZGVsLmlkICYmIGVkZ2UubGFiZWwgPT09ICfnsbvlnosnKQoKICAgICAgbGV0IHJlZ2lvbiA9ICcnCiAgICAgIGxldCBnZW5yZSA9ICcnCgogICAgICBpZiAocmVnaW9uRWRnZSkgewogICAgICAgIGNvbnN0IHROb2RlID0gdGhpcy5ncmFwaERhdGEubm9kZXMuZmluZChuID0+IG4uaWQgPT09IHJlZ2lvbkVkZ2UudGFyZ2V0KQogICAgICAgIHJlZ2lvbiA9IHROb2RlID8gdE5vZGUubmFtZSA6ICcnCiAgICAgIH0KCiAgICAgIGlmIChnZW5yZUVkZ2UpIHsKICAgICAgICBjb25zdCB0Tm9kZSA9IHRoaXMuZ3JhcGhEYXRhLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBnZW5yZUVkZ2UudGFyZ2V0KQogICAgICAgIGdlbnJlID0gdE5vZGUgPyB0Tm9kZS5uYW1lIDogJycKICAgICAgfQoKICAgICAgdGhpcy5ub2RlRGV0YWlsID0gewogICAgICAgIC4uLm5vZGVNb2RlbCwKICAgICAgICBkaXJlY3RvcnM6IGRpcmVjdG9ycy5qb2luKCfjgIEnKSwKICAgICAgICBhY3RvcnM6IGFjdG9ycy5qb2luKCfjgIEnKSwKICAgICAgICByZWdpb24sCiAgICAgICAgZ2VucmUKICAgICAgfQogICAgICB0aGlzLnNob3dEZXRhaWxEaWFsb2cgPSB0cnVlCiAgICB9LAoKICAgIGZpbHRlck5vZGVzKCkgewogICAgICB0aGlzLnJlbmRlckdyYXBoKCkKICAgIH0sCgogICAgc2VhcmNoTm9kZXMoKSB7CiAgICAgIHRoaXMucmVuZGVyR3JhcGgoKQogICAgfSwKCiAgICByZXNldEdyYXBoKCkgewogICAgICB0aGlzLnNlbGVjdGVkTm9kZVR5cGUgPSAnYWxsJwogICAgICB0aGlzLnNlYXJjaEtleXdvcmQgPSAnJwogICAgICB0aGlzLmxvY2FsTW92aWVDb3VudCA9IDEwCiAgICAgIHRoaXMuZmV0Y2hHcmFwaERhdGEoKQogICAgfSwKCiAgICBvbk1vdmllQ291bnRDaGFuZ2UoKSB7CiAgICAgIHRoaXMuZmV0Y2hHcmFwaERhdGEoKQogICAgfQogIH0KfQo="},{"version":3,"sources":["KnowledgeGraph.vue"],"names":[],"mappings":";AAmFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"KnowledgeGraph.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"knowledge-graph-container\">\n    <!-- 筛选和搜索区域 -->\n    <div class=\"graph-controls\">\n      <el-select\n          v-model=\"selectedNodeType\"\n          placeholder=\"筛选节点类型\"\n          class=\"type-selector\"\n          @change=\"filterNodes\"\n      >\n        <el-option label=\"全部节点\" value=\"all\"></el-option>\n        <el-option label=\"电影\" value=\"movie\"></el-option>\n        <el-option label=\"导演\" value=\"director\"></el-option>\n        <el-option label=\"演员\" value=\"actor\"></el-option>\n        <el-option label=\"地区\" value=\"region\"></el-option>\n        <el-option label=\"类型\" value=\"genre\"></el-option>\n      </el-select>\n\n      <el-input\n          v-model=\"searchKeyword\"\n          placeholder=\"搜索节点名称\"\n          class=\"search-input\"\n          @keyup.enter=\"searchNodes\"\n      >\n        <el-button slot=\"append\" icon=\"el-icon-search\" @click=\"searchNodes\"></el-button>\n      </el-input>\n\n      <el-input-number\n          v-model=\"localMovieCount\"\n          placeholder=\"电影数量\"\n          class=\"movie-count-input\"\n          :min=\"1\"\n          :max=\"100\"\n          @change=\"onMovieCountChange\"\n      ></el-input-number>\n\n      <el-button type=\"primary\" @click=\"resetGraph\" class=\"reset-btn\">重置图谱</el-button>\n    </div>\n\n    <!-- 图谱渲染画布：使用绝对定位占满剩余空间 -->\n    <div ref=\"graphCanvas\" class=\"graph-canvas\"></div>\n\n    <!-- 电影详情弹窗 -->\n    <el-dialog\n        title=\"电影详情\"\n        :visible.sync=\"showDetailDialog\"\n        width=\"550px\"\n        append-to-body\n        destroy-on-close\n        custom-class=\"detail-dialog\"\n    >\n      <div class=\"detail-card\">\n        <div class=\"detail-header\">\n          <h3 class=\"movie-title\">{{ nodeDetail && nodeDetail.name || '' }}</h3>\n          <span class=\"movie-rating\">\n            <i class=\"el-icon-star-on\" style=\"color: #ffd700;\"></i>\n            {{ nodeDetail && nodeDetail.rating || '暂无' }}分\n          </span>\n        </div>\n        <div class=\"detail-content\">\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">导演：</span>\n            <span class=\"detail-value\">{{ nodeDetail && nodeDetail.directors || '无' }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">演员：</span>\n            <span class=\"detail-value\">{{ nodeDetail && nodeDetail.actors || '无' }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">地区：</span>\n            <span class=\"detail-value\">{{ nodeDetail && nodeDetail.region || '无' }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">类型：</span>\n            <span class=\"detail-value\">{{ nodeDetail && nodeDetail.genre || '无' }}</span>\n          </div>\n        </div>\n      </div>\n    </el-dialog>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios'\nconst echarts = require('echarts')\n\nexport default {\n  name: 'KnowledgeGraph',\n  props: {\n    movieCount: {\n      type: Number,\n      default: 10\n    },\n    currentUser: {\n      type: Object,\n      default: null\n    }\n  },\n  data() {\n    return {\n      graphInstance: null,\n      graphData: {\n        nodes: [],\n        edges: []\n      },\n      selectedNodeType: 'all',\n      searchKeyword: '',\n      showDetailDialog: false,\n      nodeDetail: null,\n      localMovieCount: 10,\n      coreMovieMap: new Map(), // 存储电影节点ID -> 子节点ID数组\n      nodePositions: new Map(), // 存储节点位置关系，用于跟随拖动\n      isDragging: false,\n      draggedNode: null,\n      dragStartPos: { x: 0, y: 0 }\n    }\n  },\n  mounted() {\n    this.$nextTick(() => {\n      // 确保画布DOM完全加载后初始化\n      if (this.$refs.graphCanvas) {\n        this.initGraph()\n        this.localMovieCount = this.movieCount || 10\n        this.fetchGraphData()\n      } else {\n        this.$message.error('图谱画布DOM元素未找到！')\n      }\n    })\n  },\n  beforeDestroy() {\n    // 彻底销毁实例和事件，避免内存泄漏\n    if (this.graphInstance) {\n      this.graphInstance.off('dragstart')\n      this.graphInstance.off('drag')\n      this.graphInstance.off('dragend')\n      this.graphInstance.dispose()\n      this.graphInstance = null\n    }\n    window.removeEventListener('resize', this.handleResize)\n  },\n  methods: {\n    // 处理窗口大小变化\n    handleResize() {\n      if (this.graphInstance) {\n        this.graphInstance.resize()\n      }\n    },\n\n    initGraph() {\n      if (!echarts) {\n        this.$message.error('ECharts库加载失败！')\n        return\n      }\n      // 初始化ECharts实例\n      this.graphInstance = echarts.init(this.$refs.graphCanvas)\n\n      // 监听窗口大小变化\n      window.addEventListener('resize', this.handleResize)\n\n      // 绑定点击事件\n      this.graphInstance.on('click', (params) => {\n        if (params.dataType === 'node') {\n          this.showNodeDetail(params.data)\n        }\n      })\n    },\n\n    fetchGraphData() {\n      const apiUrl = `http://localhost:8081/api/kg/graph-data?movieCount=${this.localMovieCount}`\n      axios.get(apiUrl)\n          .then(res => {\n            if (res.status === 200) {\n              this.graphData = res.data.data || res.data\n              this.renderGraph()\n            }\n          })\n          .catch(err => {\n            this.$message.error('数据请求失败：' + err.message)\n            console.error('图谱数据请求失败：', err)\n          })\n    },\n\n    // 优化后的节点大小计算\n    getNodeSize(name, isCore) {\n      const fontSize = isCore ? 14 : 12\n      const baseSize = isCore ? 60 : 40\n      const length = name ? name.length : 0\n\n      // 根据文本长度调整大小\n      if (length <= 4) return baseSize\n      if (length <= 8) return baseSize * 1.2\n      return baseSize * 1.5\n    },\n\n    // 生成图谱数据（核心改进：建立节点跟随关系）\n    generateGraphData() {\n      let allNodes = [...this.graphData.nodes]\n      let allEdges = [...this.graphData.edges]\n\n      // 清空之前的映射\n      this.coreMovieMap.clear()\n      this.nodePositions.clear()\n\n      // 筛选逻辑\n      let filteredNodes = []\n      let filteredEdges = []\n\n      if (this.selectedNodeType === 'all') {\n        filteredNodes = allNodes\n        filteredEdges = allEdges\n      } else {\n        const targetNodes = allNodes.filter(node => node.type === this.selectedNodeType)\n        if (targetNodes.length === 0) {\n          return { nodes: [], edges: [], categories: this.getNodeCategories() }\n        }\n        const targetNodeIds = targetNodes.map(node => node.id)\n        const relatedEdges = allEdges.filter(edge =>\n            targetNodeIds.includes(edge.source) || targetNodeIds.includes(edge.target)\n        )\n        const relatedNodeIds = new Set()\n        relatedEdges.forEach(edge => {\n          relatedNodeIds.add(edge.source)\n          relatedNodeIds.add(edge.target)\n        })\n        filteredNodes = allNodes.filter(node => relatedNodeIds.has(node.id))\n        filteredEdges = relatedEdges\n      }\n\n      // 关键词搜索\n      if (this.searchKeyword) {\n        const keyword = this.searchKeyword.trim().toLowerCase()\n        filteredNodes = filteredNodes.filter(node => node.name && node.name.toLowerCase().includes(keyword))\n        const filteredNodeIds = filteredNodes.map(node => node.id)\n        filteredEdges = filteredEdges.filter(edge =>\n            filteredNodeIds.includes(edge.source) && filteredNodeIds.includes(edge.target)\n        )\n      }\n\n      const nodeCategories = this.getNodeCategories()\n\n      // 收集所有电影节点\n      const movieNodes = filteredNodes.filter(node => node.type === 'movie')\n\n      // 第一步：建立电影节点与子节点的映射关系\n      movieNodes.forEach(movieNode => {\n        if (!movieNode.id) return\n\n        // 找到与当前电影节点相关的边\n        const movieEdges = filteredEdges.filter(edge =>\n            edge.source === movieNode.id || edge.target === movieNode.id\n        )\n\n        // 收集所有子节点ID\n        const childNodeIds = []\n        movieEdges.forEach(edge => {\n          const childId = edge.source === movieNode.id ? edge.target : edge.source\n          // 排除电影节点自身\n          const childNode = filteredNodes.find(n => n.id === childId && n.type !== 'movie')\n          if (childNode) {\n            childNodeIds.push(childId)\n          }\n        })\n\n        // 存储映射关系\n        this.coreMovieMap.set(movieNode.id, childNodeIds)\n\n        // 为每个子节点存储其父电影节点的位置关系\n        childNodeIds.forEach(childId => {\n          if (!this.nodePositions.has(childId)) {\n            this.nodePositions.set(childId, new Set())\n          }\n          this.nodePositions.get(childId).add(movieNode.id)\n        })\n      })\n\n      // 第二步：计算布局\n      const nodes = []\n      const edges = []\n\n      // 计算画布中心点\n      const canvasWidth = this.$refs.graphCanvas.offsetWidth\n      const canvasHeight = this.$refs.graphCanvas.offsetHeight\n      const centerX = canvasWidth / 2\n      const centerY = canvasHeight / 2\n\n      // 使用放射状布局\n      const radiusPerMovie = Math.min(canvasWidth, canvasHeight) * 0.35 / Math.max(1, movieNodes.length)\n\n      // 处理电影节点\n      movieNodes.forEach((movieNode, index) => {\n        if (!movieNode.id) return\n\n        // 计算电影节点位置（放射状布局）\n        const angle = (index / movieNodes.length) * 2 * Math.PI\n        const distance = radiusPerMovie * (index + 1)\n        const movieX = centerX + distance * Math.cos(angle)\n        const movieY = centerY + distance * Math.sin(angle)\n\n        // 添加电影节点\n        nodes.push({\n          id: movieNode.id,\n          name: movieNode.name,\n          category: 0,\n          x: movieX,\n          y: movieY,\n          symbolSize: this.getNodeSize(movieNode.name, true),\n          itemStyle: nodeCategories[0].itemStyle,\n          label: {\n            show: true,\n            fontSize: 12,\n            fontWeight: 'bold',\n            color: '#000',\n            overflow: 'break',\n            lineHeight: 16\n          },\n          draggable: true,\n          type: 'movie'\n        })\n\n        // 添加电影节点的子节点\n        const childNodeIds = this.coreMovieMap.get(movieNode.id) || []\n        childNodeIds.forEach((childId, childIndex) => {\n          const childNode = filteredNodes.find(n => n.id === childId)\n          if (!childNode) return\n\n          // 检查是否已经添加过该子节点（避免重复）\n          if (nodes.find(n => n.id === childId)) return\n\n          // 计算子节点位置（围绕电影节点，放射状分布）\n          const angle = (childIndex / childNodeIds.length) * Math.PI * 2\n          const radius = 80 // 固定半径，确保子节点围绕父节点合适距离\n          const childX = movieX + radius * Math.cos(angle)\n          const childY = movieY + radius * Math.sin(angle)\n\n          // 确定节点类型索引\n          const catIdx = nodeCategories.findIndex(c => c.name === childNode.type)\n\n          nodes.push({\n            id: childNode.id,\n            name: childNode.name,\n            category: catIdx >= 0 ? catIdx : 4,\n            x: childX,\n            y: childY,\n            symbolSize: this.getNodeSize(childNode.name, false),\n            itemStyle: nodeCategories[catIdx >= 0 ? catIdx : 4].itemStyle,\n            label: {\n              show: true,\n              fontSize: 10,\n              color: '#000',\n              overflow: 'break',\n              lineHeight: 14\n            },\n            draggable: true,\n            type: childNode.type\n          })\n        })\n      })\n\n      // 第三步：添加边\n      filteredEdges.forEach(edge => {\n        // 确保边的两个节点都存在\n        if (nodes.find(n => n.id === edge.source) && nodes.find(n => n.id === edge.target)) {\n          edges.push({\n            source: edge.source,\n            target: edge.target,\n            label: {\n              show: true,\n              formatter: edge.label,\n              fontSize: 10,\n              color: '#666',\n              position: 'middle'\n            },\n            lineStyle: {\n              width: 1.5,\n              color: '#B0C4DE',\n              type: 'solid',\n              opacity: 0.8\n            }\n          })\n        }\n      })\n\n      return {\n        nodes: nodes,\n        edges: edges,\n        categories: nodeCategories\n      }\n    },\n\n    getNodeCategories() {\n      return [\n        { name: 'movie', itemStyle: { color: '#8A2BE2', borderWidth: 2, borderColor: '#4B0082' } },\n        { name: 'director', itemStyle: { color: '#FF4500', borderWidth: 1, borderColor: '#FF6347' } },\n        { name: 'actor', itemStyle: { color: '#FF6347', borderWidth: 1, borderColor: '#FF4500' } },\n        { name: 'region', itemStyle: { color: '#FFD700', borderWidth: 1, borderColor: '#FFA500' } },\n        { name: 'genre', itemStyle: { color: '#32CD32', borderWidth: 1, borderColor: '#228B22' } }\n      ]\n    },\n\n    renderGraph() {\n      if (!this.graphInstance) return\n\n      const graphData = this.generateGraphData()\n      const _this = this\n\n      // 计算画布大小\n      const containerWidth = this.$refs.graphCanvas.offsetWidth\n      const containerHeight = this.$refs.graphCanvas.offsetHeight\n\n      // ECharts配置\n      const option = {\n        backgroundColor: '#FFFFFF',\n        tooltip: {\n          trigger: 'item',\n          backgroundColor: 'rgba(255,255,255,0.95)',\n          borderColor: '#E5E5E5',\n          borderWidth: 1,\n          borderRadius: 6,\n          padding: [8, 12],\n          textStyle: { color: '#333', fontSize: 12 },\n          formatter: params => {\n            if (params.dataType === 'node') {\n              const types = ['电影','导演','演员','地区','类型']\n              return `${params.name}<br/>类型：${types[params.data.category] || '未知'}`\n            }\n            return params.dataType === 'edge' ? `关系：${params.data.label.formatter}` : params.name\n          }\n        },\n        legend: {\n          show: true,\n          data: [\n            {name:'电影', icon: 'circle', textStyle: {color: '#8A2BE2'}},\n            {name:'导演', icon: 'circle', textStyle: {color: '#FF4500'}},\n            {name:'演员', icon: 'circle', textStyle: {color: '#FF6347'}},\n            {name:'地区', icon: 'circle', textStyle: {color: '#FFD700'}},\n            {name:'类型', icon: 'circle', textStyle: {color: '#32CD32'}}\n          ],\n          top: 10,\n          left: 'center',\n          itemGap: 15,\n          textStyle: { fontSize: 12, color: '#000' },\n          icon: 'circle'\n        },\n        series: [\n          {\n            type: 'graph',\n            layout: 'none',\n            roam: true,\n            zoom: 1,\n            center: ['50%', '50%'],\n            draggable: true,\n            symbol: 'circle',\n            symbolSize: 40,\n            edgeSymbol: ['circle', 'circle'],\n            edgeSymbolSize: [4, 4],\n            cursor: 'move',\n            label: {\n              show: true,\n              position: 'inside',\n              color: '#000',\n              fontSize: 10,\n              fontWeight: 'normal'\n            },\n            edgeLabel: {\n              show: true,\n              position: 'middle',\n              fontSize: 10\n            },\n            data: graphData.nodes,\n            links: graphData.edges,\n            categories: graphData.categories,\n            lineStyle: {\n              color: 'source',\n              width: 1.5,\n              curveness: 0.1,\n              opacity: 0.6\n            },\n            emphasis: {\n              focus: 'adjacency',\n              lineStyle: {\n                width: 2,\n                opacity: 1\n              }\n            }\n          }\n        ]\n      }\n\n      // 清空并设置新配置\n      this.graphInstance.clear()\n      this.graphInstance.setOption(option, true)\n\n      // 移除旧的事件监听器\n      this.graphInstance.off('dragstart')\n      this.graphInstance.off('drag')\n      this.graphInstance.off('dragend')\n\n      // 拖动开始事件\n      this.graphInstance.on('dragstart', function(params) {\n        if (params.dataType !== 'node') return\n\n        _this.isDragging = true\n        _this.draggedNode = params.data\n        _this.dragStartPos = {\n          x: params.data.x,\n          y: params.data.y\n        }\n      })\n\n      // 拖动事件 - 核心：子节点跟随父节点\n      this.graphInstance.on('drag', function(params) {\n        if (!_this.isDragging || params.dataType !== 'node') return\n\n        const currentNode = params.data\n        const dx = currentNode.x - _this.dragStartPos.x\n        const dy = currentNode.y - _this.dragStartPos.y\n\n        // 如果是电影节点被拖动，移动所有子节点\n        if (currentNode.type === 'movie' && _this.coreMovieMap.has(currentNode.id)) {\n          const childNodeIds = _this.coreMovieMap.get(currentNode.id)\n          const graphOption = _this.graphInstance.getOption()\n          const allNodes = graphOption.series[0].data\n\n          // 更新所有子节点的位置\n          childNodeIds.forEach(childId => {\n            const childNode = allNodes.find(n => n.id === childId)\n            if (childNode) {\n              childNode.x += dx\n              childNode.y += dy\n            }\n          })\n\n          // 更新图表\n          _this.graphInstance.setOption({\n            series: [{\n              data: allNodes\n            }]\n          }, true) // 使用true参数强制更新\n        }\n\n        // 如果是子节点被拖动，检查它是否属于多个父节点\n        else if (currentNode.type !== 'movie' && _this.nodePositions.has(currentNode.id)) {\n          const parentMovieIds = Array.from(_this.nodePositions.get(currentNode.id))\n          const graphOption = _this.graphInstance.getOption()\n          const allNodes = graphOption.series[0].data\n\n          // 找到对应的父电影节点\n          parentMovieIds.forEach(parentId => {\n            const parentNode = allNodes.find(n => n.id === parentId && n.type === 'movie')\n            if (parentNode) {\n              // 计算父节点的新位置（保持相对位置不变）\n              const relativeX = currentNode.x - _this.dragStartPos.x\n              const relativeY = currentNode.y - _this.dragStartPos.y\n              parentNode.x += relativeX\n              parentNode.y += relativeY\n\n              // 移动该父节点的其他子节点\n              if (_this.coreMovieMap.has(parentId)) {\n                const siblingIds = _this.coreMovieMap.get(parentId)\n                siblingIds.forEach(siblingId => {\n                  if (siblingId !== currentNode.id) {\n                    const siblingNode = allNodes.find(n => n.id === siblingId)\n                    if (siblingNode) {\n                      siblingNode.x += relativeX\n                      siblingNode.y += relativeY\n                    }\n                  }\n                })\n              }\n            }\n          })\n\n          // 更新图表\n          _this.graphInstance.setOption({\n            series: [{\n              data: allNodes\n            }]\n          }, true) // 使用true参数强制更新\n        }\n\n        // 更新起始位置\n        _this.dragStartPos = {\n          x: currentNode.x,\n          y: currentNode.y\n        }\n      })\n\n      // 拖动结束事件\n      this.graphInstance.on('dragend', function() {\n        _this.isDragging = false\n        _this.draggedNode = null\n        _this.dragStartPos = { x: 0, y: 0 }\n      })\n\n      // 点击节点事件\n      this.graphInstance.on('click', params => {\n        if (params.dataType === 'node') {\n          _this.showNodeDetail(params.data)\n        }\n      })\n\n      // 确保图表适应容器大小\n      this.graphInstance.resize()\n    },\n\n    showNodeDetail(nodeModel) {\n      if (nodeModel.category !== 0) {\n        this.$message.info(`${nodeModel.name} | ${['电影','导演','演员','地区','类型'][nodeModel.category] || '未知'}`)\n        return\n      }\n\n      // 获取电影详情信息\n      const directors = this.graphData.edges\n          .filter(edge => edge.source === nodeModel.id && edge.label === '导演')\n          .map(edge => {\n            const tNode = this.graphData.nodes.find(n => n.id === edge.target)\n            return tNode ? tNode.name : null\n          })\n          .filter(Boolean)\n\n      const actors = this.graphData.edges\n          .filter(edge => edge.source === nodeModel.id && edge.label === '主演')\n          .map(edge => {\n            const tNode = this.graphData.nodes.find(n => n.id === edge.target)\n            return tNode ? tNode.name : null\n          })\n          .filter(Boolean)\n\n      const regionEdge = this.graphData.edges.find(edge => edge.source === nodeModel.id && edge.label === '地区')\n      const genreEdge = this.graphData.edges.find(edge => edge.source === nodeModel.id && edge.label === '类型')\n\n      let region = ''\n      let genre = ''\n\n      if (regionEdge) {\n        const tNode = this.graphData.nodes.find(n => n.id === regionEdge.target)\n        region = tNode ? tNode.name : ''\n      }\n\n      if (genreEdge) {\n        const tNode = this.graphData.nodes.find(n => n.id === genreEdge.target)\n        genre = tNode ? tNode.name : ''\n      }\n\n      this.nodeDetail = {\n        ...nodeModel,\n        directors: directors.join('、'),\n        actors: actors.join('、'),\n        region,\n        genre\n      }\n      this.showDetailDialog = true\n    },\n\n    filterNodes() {\n      this.renderGraph()\n    },\n\n    searchNodes() {\n      this.renderGraph()\n    },\n\n    resetGraph() {\n      this.selectedNodeType = 'all'\n      this.searchKeyword = ''\n      this.localMovieCount = 10\n      this.fetchGraphData()\n    },\n\n    onMovieCountChange() {\n      this.fetchGraphData()\n    }\n  }\n}\n</script>\n\n<style scoped>\n.knowledge-graph-container {\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n  background-color: #FFFFFF;\n  overflow: hidden;\n  position: relative;\n  margin: 0;\n  padding: 0;\n}\n\n.graph-controls {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  padding: 12px 20px;\n  background-color: #F8F9FA;\n  border-bottom: 1px solid #E5E5E5;\n  flex-shrink: 0;\n  z-index: 10;\n  flex-wrap: wrap;\n}\n\n.type-selector {\n  width: 160px;\n  min-width: 160px;\n}\n\n.search-input {\n  flex: 1;\n  min-width: 200px;\n  max-width: 300px;\n}\n\n.movie-count-input {\n  width: 140px;\n  min-width: 140px;\n}\n\n.reset-btn {\n  background-color: #8A2BE2;\n  border-color: #8A2BE2;\n  color: white;\n  padding: 0 20px;\n}\n\n.reset-btn:hover {\n  background-color: #7B2BBE;\n  border-color: #7B2BBE;\n}\n\n/* 关键改进：画布占满剩余空间 */\n.graph-canvas {\n  flex: 1;\n  width: 100%;\n  min-height: 0; /* 防止flex项目溢出 */\n  overflow: hidden;\n  background-color: #FFFFFF;\n}\n\n/* 详情弹窗样式 */\n.detail-dialog {\n  border-radius: 8px;\n  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);\n}\n\n.detail-card {\n  padding: 24px;\n}\n\n.detail-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  margin-bottom: 20px;\n  padding-bottom: 16px;\n  border-bottom: 2px solid #F0F0F0;\n}\n\n.movie-title {\n  font-size: 20px;\n  font-weight: 700;\n  color: #333;\n  margin: 0;\n  line-height: 1.4;\n  flex: 1;\n}\n\n.movie-rating {\n  font-size: 14px;\n  color: #FFA500;\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  font-weight: 600;\n  white-space: nowrap;\n  margin-left: 12px;\n}\n\n.detail-content {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n\n.detail-item {\n  display: flex;\n  align-items: flex-start;\n}\n\n.detail-label {\n  width: 60px;\n  font-size: 14px;\n  color: #666;\n  font-weight: 600;\n  flex-shrink: 0;\n}\n\n.detail-value {\n  flex: 1;\n  font-size: 14px;\n  color: #333;\n  line-height: 1.6;\n  word-break: break-word;\n}\n\n/* 响应式设计 */\n@media (max-width: 768px) {\n  .knowledge-graph-container {\n    height: 100vh;\n  }\n\n  .graph-controls {\n    padding: 10px 15px;\n    gap: 12px;\n  }\n\n  .type-selector,\n  .search-input,\n  .movie-count-input {\n    width: 100%;\n    min-width: unset;\n    max-width: unset;\n  }\n\n  .reset-btn {\n    width: 100%;\n    padding: 12px;\n  }\n\n  .graph-canvas {\n    height: calc(100vh - 160px);\n  }\n}\n\n@media (max-width: 480px) {\n  .graph-controls {\n    flex-direction: column;\n    align-items: stretch;\n  }\n\n  .movie-title {\n    font-size: 18px;\n  }\n\n  .detail-label,\n  .detail-value {\n    font-size: 13px;\n  }\n}\n</style>"]}]}